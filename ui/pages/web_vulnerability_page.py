"""
Web vulnerability scanner page for Astra
"""

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QLineEdit,
                            QProgressBar, QTableWidget, QTableWidgetItem, QGroupBox, QFormLayout,
                            QHeaderView, QCheckBox, QMessageBox, QSizePolicy, QDialog, QTextEdit)
from PyQt6.QtCore import Qt, QThread, QSize
from PyQt6.QtGui import QFont, QColor, QResizeEvent, QDragEnterEvent, QDropEvent

from core.web_vulnerability import WebVulnerabilityScanner
from utils.report_generator import ReportGenerator
from core.dynamic_scanner import DynamicScanner
from utils.ai_report_enhancer import AIReportEnhancer

# Try to import AI-related modules
try:
    from core.ai_threat_detection import AIThreatDetector
    AI_AVAILABLE = True
except ImportError:
    AI_AVAILABLE = False

class ScannerThread(QThread):
    """Thread for running web vulnerability scanner without blocking GUI"""
    
    def __init__(self, scanner, url, use_dynamic_scanner=False, scan_options=None):
        super().__init__()
        self.scanner = scanner
        self.url = url
        self.use_dynamic_scanner = use_dynamic_scanner
        self.scan_options = scan_options or {}
    
    def run(self):
        """Run the scanner in a thread"""
        if self.use_dynamic_scanner and isinstance(self.scanner, DynamicScanner):
            self.scanner.scan(self.url, self.scan_options)
        else:
            self.scanner.scan(self.url)

class WebVulnerabilityPage(QWidget):
    """Web vulnerability scanner page widget"""
    
    def __init__(self):
        super().__init__()
        self.scanner = WebVulnerabilityScanner()
        
        # Initialize dynamic scanner if available
        self.dynamic_scanner = None
        try:
            self.dynamic_scanner = DynamicScanner()
            self.has_dynamic_scanner = True
        except Exception:
            self.has_dynamic_scanner = False
        
        self.thread = None
        self.report_generator = ReportGenerator()
        self.scan_results = []  # Store scan results for reporting
        
        # Initialize AI report enhancer
        self.ai_report_enhancer = AIReportEnhancer()
        
        self.setup_ui()
        self.connect_signals()
        self.setAcceptDrops(True)  # Enable drag and drop
    
    def setup_ui(self):
        """Setup the UI components"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Header
        header = QLabel("Web Vulnerability Scanner")
        header.setFont(QFont("Arial", 18, QFont.Weight.Bold))
        layout.addWidget(header)
        
        # Description
        desc = QLabel("Scan websites for common security vulnerabilities such as XSS, SQL Injection, and more.")
        desc.setWordWrap(True)
        layout.addWidget(desc)
        
        # Input form
        input_group = QGroupBox("Scan Configuration")
        form_layout = QFormLayout(input_group)
        
        # URL input
        self.url_input = QLineEdit()
        self.url_input.setPlaceholderText("Enter URL to scan (e.g., https://example.com)")
        form_layout.addRow("Target URL:", self.url_input)
        
        # Options
        options_layout = QHBoxLayout()
        
        # Use dynamic scanner option
        self.dynamic_scanner_check = QCheckBox("Use Dynamic Scanner")
        self.dynamic_scanner_check.setChecked(self.has_dynamic_scanner)
        self.dynamic_scanner_check.setEnabled(self.has_dynamic_scanner)
        self.dynamic_scanner_check.setToolTip(
            "Enable JavaScript-based vulnerability detection with Selenium" if self.has_dynamic_scanner
            else "Selenium not available. Install selenium package to enable dynamic scanning."
        )
        options_layout.addWidget(self.dynamic_scanner_check)
        
        # AI-powered analysis option
        self.ai_analysis_check = QCheckBox("Use AI Analysis")
        self.ai_analysis_check.setChecked(AI_AVAILABLE)
        self.ai_analysis_check.setEnabled(AI_AVAILABLE)
        self.ai_analysis_check.setToolTip(
            "Enable AI-powered vulnerability detection and analysis" if AI_AVAILABLE
            else "scikit-learn not available. Install scikit-learn package to enable AI analysis."
        )
        options_layout.addWidget(self.ai_analysis_check)
        
        # Add options to form
        form_layout.addRow("Advanced Options:", options_layout)
        
        # Checkbox options
        check_layout = QHBoxLayout()
        self.thorough_check = QCheckBox("Thorough Scan")
        self.thorough_check.setToolTip("Perform a more comprehensive scan (slower)")
        
        self.xss_check = QCheckBox("XSS")
        self.xss_check.setChecked(True)
        self.xss_check.setToolTip("Check for Cross-Site Scripting vulnerabilities")
        
        self.sqli_check = QCheckBox("SQL Injection")
        self.sqli_check.setChecked(True)
        self.sqli_check.setToolTip("Check for SQL Injection vulnerabilities")
        
        self.header_check = QCheckBox("Security Headers")
        self.header_check.setChecked(True)
        self.header_check.setToolTip("Check for missing security headers")
        
        self.info_check = QCheckBox("Information Disclosure")
        self.info_check.setChecked(True)
        self.info_check.setToolTip("Check for information disclosure vulnerabilities")
        
        check_layout.addWidget(self.thorough_check)
        check_layout.addWidget(self.xss_check)
        check_layout.addWidget(self.sqli_check)
        check_layout.addWidget(self.header_check)
        check_layout.addWidget(self.info_check)
        
        form_layout.addRow("Scan Types:", check_layout)
        
        layout.addWidget(input_group)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)
        layout.addWidget(self.progress_bar)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        self.scan_button = QPushButton("Start Scan")
        self.scan_button.setMinimumWidth(120)
        
        self.stop_button = QPushButton("Stop")
        self.stop_button.setEnabled(False)
        self.stop_button.setMinimumWidth(120)
        
        self.clear_button = QPushButton("Clear Results")
        self.clear_button.setMinimumWidth(120)
        
        self.generate_pdf_button = QPushButton("Generate PDF Report")
        self.generate_pdf_button.setFixedWidth(200)
        self.generate_pdf_button.setEnabled(False)
        
        self.generate_html_button = QPushButton("Generate HTML Report")
        self.generate_html_button.setFixedWidth(200)
        self.generate_html_button.setEnabled(False)
        
        button_layout.addWidget(self.scan_button)
        button_layout.addWidget(self.stop_button)
        button_layout.addWidget(self.clear_button)
        button_layout.addWidget(self.generate_pdf_button)
        button_layout.addWidget(self.generate_html_button)
        button_layout.addStretch()
        
        layout.addLayout(button_layout)
        
        # Results table
        self.results_table = QTableWidget(0, 5)  # 5 columns: Type, URL, Description, Severity, Risk Score
        self.results_table.setHorizontalHeaderLabels(["Vulnerability", "URL", "Description", "Severity", "Risk Score"])
        self.results_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.results_table.verticalHeader().setVisible(False)
        self.results_table.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        layout.addWidget(self.results_table)
        
        # Status label
        self.status_label = QLabel("Enter a URL to scan for vulnerabilities")
        self.status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.status_label)
    
    def connect_signals(self):
        """Connect signals to slots"""
        self.scan_button.clicked.connect(self.start_scan)
        self.stop_button.clicked.connect(self.stop_scan)
        self.clear_button.clicked.connect(self.clear_results)
        self.generate_pdf_button.clicked.connect(self.generate_pdf_report)
        self.generate_html_button.clicked.connect(self.generate_html_report)
        
        # Connect scanner signals
        self.scanner.progress_update.connect(self.update_progress)
        self.scanner.result_update.connect(self.update_result)
        self.scanner.scan_completed.connect(self.scan_finished)
        self.scanner.scan_error.connect(self.show_error)
        
        # Connect dynamic scanner signals if available
        if self.dynamic_scanner:
            self.dynamic_scanner.progress_update.connect(self.update_progress)
            self.dynamic_scanner.result_update.connect(self.update_result)
            self.dynamic_scanner.scan_completed.connect(self.scan_finished)
            self.dynamic_scanner.scan_error.connect(self.show_error)
            self.dynamic_scanner.log_message.connect(self.log_message)
    
    def start_scan(self):
        """Start the web vulnerability scanning process"""
        # Clear previous results if any exist
        if self.results_table.rowCount() > 0:
            self.clear_results()
        
        # Get parameters
        url = self.url_input.text().strip()
        if not url:
            self.show_error("Please enter a URL")
            return
        
        # Validate URL format
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
            self.url_input.setText(url)
        
        # Determine which scanner to use
        use_dynamic = self.dynamic_scanner_check.isChecked() and self.has_dynamic_scanner
        scanner_to_use = self.dynamic_scanner if use_dynamic else self.scanner
        
        # Set scan options
        scan_options = {
            'thorough': self.thorough_check.isChecked(),
            'check_xss': self.xss_check.isChecked(),
            'check_sqli': self.sqli_check.isChecked(),
            'check_headers': self.header_check.isChecked(),
            'check_info': self.info_check.isChecked(),
            'use_ai_detection': self.ai_analysis_check.isChecked() and AI_AVAILABLE,
            'use_ml_fuzzing': self.ai_analysis_check.isChecked() and AI_AVAILABLE
        }
        
        # Set scan options for regular scanner
        if not use_dynamic:
            self.scanner.set_scan_options(
                thorough=scan_options['thorough'],
                check_xss=scan_options['check_xss'],
                check_sqli=scan_options['check_sqli'],
                check_headers=scan_options['check_headers'],
                check_info=scan_options['check_info']
            )
        
        # Update UI
        self.scan_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.clear_button.setEnabled(False)
        self.generate_pdf_button.setEnabled(False)
        self.generate_html_button.setEnabled(False)
        self.progress_bar.setValue(0)
        
        # Update status
        scanner_type = "Dynamic" if use_dynamic else "Standard"
        ai_enabled = "with AI analysis" if self.ai_analysis_check.isChecked() and AI_AVAILABLE else ""
        self.status_label.setText(f"Running {scanner_type} scan on {url} {ai_enabled}...")
        
        # Start scanning in a thread
        self.thread = ScannerThread(
            scanner_to_use,
            url,
            use_dynamic,
            scan_options
        )
        self.thread.start()
    
    def stop_scan(self):
        """Stop the scanning process"""
        if self.thread and self.thread.isRunning():
            # Determine which scanner is active
            if self.thread.use_dynamic_scanner:
                self.dynamic_scanner.stop()
            else:
                self.scanner.stop_scan()
                
            self.thread.wait()
            self.scan_finished()
    
    def clear_results(self):
        """Clear the results table and reset progress"""
        self.results_table.setRowCount(0)
        self.progress_bar.setValue(0)
        self.scan_results = []
        self.generate_pdf_button.setEnabled(False)
        self.generate_html_button.setEnabled(False)
        self.status_label.setText("Results cleared")
    
    def update_progress(self, value):
        """Update the progress bar"""
        self.progress_bar.setValue(value)
    
    def log_message(self, message):
        """Handle log messages from scanner"""
        # Update status label with latest log message
        self.status_label.setText(message)
        
        # Could also log to a log panel if we had one
        print(f"Scanner log: {message}")
    
    def update_result(self, vulnerability, url, description, severity):
        """Update the results table with a new scan result"""
        # Store result for reporting
        self.scan_results.append((vulnerability, url, description, severity))
        
        # Enhance with AI risk scoring and mitigation strategies
        enhanced_description, risk_score, risk_color = self.ai_report_enhancer.enhance_vulnerability_report(
            vulnerability, url, description, severity
        )
        
        # Add to table
        row = self.results_table.rowCount()
        self.results_table.insertRow(row)
        
        # Create table items
        vuln_item = QTableWidgetItem(vulnerability)
        url_item = QTableWidgetItem(url)
        desc_item = QTableWidgetItem(enhanced_description)
        severity_item = QTableWidgetItem(severity)
        risk_score_item = QTableWidgetItem(str(int(risk_score)))
        
        # Set alignment
        vuln_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        url_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        severity_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        risk_score_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Set severity color
        severity_color = {
            "CRITICAL": QColor(128, 0, 0),  # Dark red
            "HIGH": QColor(255, 0, 0),      # Red
            "MEDIUM": QColor(255, 153, 0),  # Orange
            "LOW": QColor(0, 170, 0)        # Green
        }.get(severity, QColor(0, 0, 0))    # Default black
        
        severity_item.setForeground(severity_color)
        risk_score_item.setForeground(risk_color)
        
        # Add items to table
        self.results_table.setItem(row, 0, vuln_item)
        self.results_table.setItem(row, 1, url_item)
        self.results_table.setItem(row, 2, desc_item)
        self.results_table.setItem(row, 3, severity_item)
        self.results_table.setItem(row, 4, risk_score_item)
        
        # Auto-resize rows to fit content
        self.results_table.resizeRowsToContents()
    
    def scan_finished(self):
        """Handle scan completion"""
        # Update UI
        self.scan_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        self.clear_button.setEnabled(True)
        
        # Enable report buttons if we have results
        has_results = len(self.scan_results) > 0
        self.generate_pdf_button.setEnabled(has_results)
        self.generate_html_button.setEnabled(has_results)
        
        if has_results:
            total_issues = len(self.scan_results)
            high_severity = sum(1 for _, _, _, severity in self.scan_results if severity in ["HIGH", "CRITICAL"])
            
            # Generate executive summary
            summary = self.ai_report_enhancer.generate_executive_summary(self.scan_results)
            
            # Update status with summary info
            self.status_label.setText(f"Scan completed. Found {total_issues} issues ({high_severity} high severity)")
            
            # Show summary dialog
            self.show_summary_dialog(summary)
        else:
            self.status_label.setText("Scan completed. No vulnerabilities found!")
    
    def show_summary_dialog(self, summary):
        """Show a dialog with the executive summary"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Scan Summary")
        dialog.resize(600, 400)
        
        layout = QVBoxLayout(dialog)
        
        # Summary text display
        summary_text = QTextEdit()
        summary_text.setReadOnly(True)
        summary_text.setPlainText(summary)
        summary_text.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
        
        layout.addWidget(summary_text)
        
        # Close button
        close_button = QPushButton("Close")
        close_button.clicked.connect(dialog.accept)
        
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(close_button)
        
        layout.addLayout(button_layout)
        
        dialog.exec()
    
    def show_error(self, message):
        """Display an error message"""
        QMessageBox.critical(self, "Error", message)
        self.status_label.setText(f"Error: {message}")
        self.scan_button.setEnabled(True)
        self.stop_button.setEnabled(False)
    
    def generate_pdf_report(self):
        """Generate a PDF report from scan results"""
        if not self.scan_results:
            self.show_error("No scan results to report")
            return
            
        url = self.url_input.text().strip()
        try:
            # Pass AI-enhanced data to the report generator
            enhanced_results = []
            for vulnerability, url, description, severity in self.scan_results:
                enhanced_description, risk_score, _ = self.ai_report_enhancer.enhance_vulnerability_report(
                    vulnerability, url, description, severity
                )
                enhanced_results.append({
                    'type': vulnerability,
                    'url': url,
                    'description': enhanced_description,
                    'severity': severity,
                    'risk_score': int(risk_score)
                })
                
            # Generate executive summary
            summary = self.ai_report_enhancer.generate_executive_summary(self.scan_results)
            
            # Pass to report generator
            filepath = self.report_generator.generate_enhanced_pdf_report(
                "Web Vulnerability Scan Results",
                enhanced_results,
                "Web Vulnerability Scan",
                url,
                summary=summary
            )
            
            QMessageBox.information(
                self, 
                "Report Generated", 
                f"PDF Report has been saved to:\n{filepath}"
            )
        except Exception as e:
            self.show_error(f"Error generating PDF report: {str(e)}")
    
    def generate_html_report(self):
        """Generate an HTML report from scan results"""
        if not self.scan_results:
            self.show_error("No scan results to report")
            return
            
        url = self.url_input.text().strip()
        try:
            # Pass AI-enhanced data to the report generator
            enhanced_results = []
            for vulnerability, url, description, severity in self.scan_results:
                enhanced_description, risk_score, _ = self.ai_report_enhancer.enhance_vulnerability_report(
                    vulnerability, url, description, severity
                )
                enhanced_results.append({
                    'type': vulnerability,
                    'url': url,
                    'description': enhanced_description,
                    'severity': severity,
                    'risk_score': int(risk_score)
                })
                
            # Generate executive summary
            summary = self.ai_report_enhancer.generate_executive_summary(self.scan_results)
            
            # Pass to report generator
            filepath = self.report_generator.generate_enhanced_html_report(
                "Web Vulnerability Scan Results",
                enhanced_results,
                "Web Vulnerability Scan",
                url,
                summary=summary
            )
            
            QMessageBox.information(
                self, 
                "Report Generated", 
                f"HTML Report has been saved to:\n{filepath}"
            )
        except Exception as e:
            self.show_error(f"Error generating HTML report: {str(e)}")
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event for file drops"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
    
    def dropEvent(self, event: QDropEvent):
        """Handle drop event for URL list files"""
        urls = event.mimeData().urls()
        if urls and urls[0].isLocalFile():
            file_path = urls[0].toLocalFile()
            try:
                with open(file_path, 'r') as f:
                    first_line = f.readline().strip()
                    if first_line.startswith(('http://', 'https://')):
                        self.url_input.setText(first_line)
                        self.status_label.setText(f"URL loaded from file: {first_line}")
            except Exception as e:
                self.status_label.setText(f"Error loading file: {str(e)}")
        elif urls:
            # If it's a direct URL drop
            url = urls[0].toString()
            if url.startswith(('http://', 'https://')):
                self.url_input.setText(url)
                self.status_label.setText(f"URL loaded: {url}")
    
    def resizeEvent(self, event: QResizeEvent):
        """Handle resize events to adjust the UI layout"""
        # Adjust column widths based on window size
        width = self.results_table.width()
        
        # Set column widths as percentages
        self.results_table.setColumnWidth(0, int(width * 0.15))  # Vulnerability type
        self.results_table.setColumnWidth(1, int(width * 0.25))  # URL
        self.results_table.setColumnWidth(2, int(width * 0.40))  # Description
        self.results_table.setColumnWidth(3, int(width * 0.10))  # Severity
        self.results_table.setColumnWidth(4, int(width * 0.10))  # Risk Score
        
        super().resizeEvent(event)
