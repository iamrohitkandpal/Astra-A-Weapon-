"""
Basic web vulnerability scanner module for Astra
"""

import threading
import re
import requests
from PyQt6.QtCore import QObject, pyqtSignal
from urllib.parse import urljoin, urlparse

class WebVulnerabilityScanner(QObject):
    """Basic web vulnerability scanner class"""
    
    # Signal for result update
    result_update = pyqtSignal(str, str, str, str)  # vulnerability, url, description, severity
    
    # Signal for progress update
    progress_update = pyqtSignal(int)
    
    # Signal for completion
    scan_completed = pyqtSignal()
    
    # Signal for error
    scan_error = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self._stop_event = threading.Event()
        # Define headers to mimic a browser request
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Referer': 'https://www.google.com/',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Cache-Control': 'max-age=0'
        }
        
        # Default scan options
        self.options = {
            'thorough': False,
            'check_xss': True,
            'check_sqli': True,
            'check_headers': True,
            'check_info': True
        }
    
    def set_scan_options(self, thorough=False, check_xss=True, check_sqli=True, 
                         check_headers=True, check_info=True):
        """Set scan options"""
        self.options['thorough'] = thorough
        self.options['check_xss'] = check_xss
        self.options['check_sqli'] = check_sqli
        self.options['check_headers'] = check_headers
        self.options['check_info'] = check_info
    
    def _check_xss(self, url, content):
        """Check for potential XSS vulnerabilities"""
        if not self.options['check_xss']:
            return
            
        # Very basic check for input fields without proper safeguards
        input_patterns = [
            r'<input.*?type=["\']text["\'].*?>',
            r'<textarea.*?>.*?</textarea>',
            r'<select.*?>.*?</select>'
        ]
        
        for pattern in input_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if 'onblur' in match or 'onclick' in match or 'onmouseover' in match:
                    continue  # Skip if there are already event handlers
                
                # Additional check for more thorough scanning
                if self.options['thorough'] and not re.search(r'input.*?sanitiz', content, re.IGNORECASE):
                    self.result_update.emit(
                        "Potential XSS",
                        url,
                        "Found input field that may be vulnerable to XSS and no evidence of input sanitization.",
                        "High"
                    )
                    return
                
                self.result_update.emit(
                    "Potential XSS",
                    url,
                    "Found input field that may be vulnerable to XSS. Input validation check recommended.",
                    "Medium"
                )
                return
    
    def _check_sqli(self, url):
        """Check for potential SQL injection vulnerabilities"""
        if not self.options['check_sqli']:
            return
            
        # Try adding a SQL injection test to a parameter
        parsed_url = urlparse(url)
        if parsed_url.query:
            params = {}
            for param in parsed_url.query.split('&'):
                if '=' in param:
                    key, value = param.split('=', 1)
                    params[key] = value
            
            # Test each parameter
            for key in params:
                test_url = url.replace(f"{key}={params[key]}", f"{key}={params[key]}'")
                try:
                    response = requests.get(test_url, headers=self.headers, timeout=5)
                    if 'SQL syntax' in response.text or 'mysql_fetch' in response.text or 'ORA-' in response.text:
                        self.result_update.emit(
                            "Potential SQL Injection",
                            url,
                            f"Parameter '{key}' may be vulnerable to SQL injection. Parameterized queries recommended.",
                            "High"
                        )
                        
                        # Check for additional SQLi vectors if thorough scanning is enabled
                        if self.options['thorough']:
                            test_url2 = url.replace(f"{key}={params[key]}", f"{key}={params[key]} OR 1=1")
                            try:
                                response2 = requests.get(test_url2, headers=self.headers, timeout=5)
                                if len(response.text) != len(response2.text):
                                    self.result_update.emit(
                                        "Confirmed SQL Injection",
                                        url,
                                        f"Parameter '{key}' appears vulnerable to boolean-based SQL injection.",
                                        "High"
                                    )
                            except Exception:
                                pass
                except Exception:
                    pass
    
    def _check_insecure_headers(self, url, headers):
        """Check for missing or insecure security headers"""
        if not self.options['check_headers']:
            return
            
        security_headers = {
            'X-XSS-Protection': 'Missing X-XSS-Protection header',
            'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
            'Content-Security-Policy': 'Missing Content-Security-Policy header',
            'X-Frame-Options': 'Missing X-Frame-Options header',
            'Strict-Transport-Security': 'Missing HSTS header'
        }
        
        for header, message in security_headers.items():
            if header not in headers:
                severity = "Medium" if header in ["Content-Security-Policy", "Strict-Transport-Security"] else "Low"
                self.result_update.emit(
                    "Missing Security Header",
                    url,
                    message,
                    severity
                )
                
        # More thorough check of existing header values if thorough scanning is enabled
        if self.options['thorough']:
            if 'X-XSS-Protection' in headers and headers['X-XSS-Protection'] != '1; mode=block':
                self.result_update.emit(
                    "Insecure Header Configuration",
                    url,
                    "X-XSS-Protection header is not set to '1; mode=block'",
                    "Low"
                )
                
            if 'X-Frame-Options' in headers and headers['X-Frame-Options'] not in ['DENY', 'SAMEORIGIN']:
                self.result_update.emit(
                    "Insecure Header Configuration",
                    url,
                    "X-Frame-Options should be set to 'DENY' or 'SAMEORIGIN'",
                    "Low"
                )
    
    def _check_information_disclosure(self, url, content, headers):
        """Check for information disclosure"""
        if not self.options['check_info']:
            return
            
        # Check for server information
        if 'Server' in headers and not headers['Server'] == '':
            server_info = headers['Server']
            self.result_update.emit(
                "Information Disclosure",
                url,
                f"Server information disclosed: {server_info}",
                "Low"
            )
        
        # Check for comments that might reveal information
        comment_patterns = [r'<!--.*?-->', r'//.*?$', r'/\*.*?\*/']
        for pattern in comment_patterns:
            matches = re.findall(pattern, content, re.DOTALL | re.MULTILINE)
            for match in matches:
                if 'password' in match.lower() or 'username' in match.lower() or 'api' in match.lower():
                    self.result_update.emit(
                        "Sensitive Information Disclosure",
                        url,
                        f"Potentially sensitive information found in comments: {match[:50]}...",
                        "Medium"
                    )
        
        # More thorough checks if enabled
        if self.options['thorough']:
            # Check for version information in HTML meta tags
            version_patterns = [r'<meta.*?version.*?content=["\']([^"\']+)["\']', r'Version:\s*([0-9.]+)']
            for pattern in version_patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                for match in matches:
                    self.result_update.emit(
                        "Version Information Disclosure",
                        url,
                        f"Software version information disclosed: {match}",
                        "Low"
                    )
            
            # Check for internal IP addresses in content
            ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
            matches = re.findall(ip_pattern, content)
            for match in matches:
                # Exclude public IPs like example IPs
                if not match.startswith(('10.', '172.16.', '192.168.', '127.')):
                    continue
                    
                self.result_update.emit(
                    "Internal IP Address Disclosure",
                    url,
                    f"Internal IP address found in page content: {match}",
                    "Medium"
                )
    
    def _check_ssl_tls(self, url):
        """Check for SSL/TLS related issues"""
        if not url.startswith('https://'):
            self.result_update.emit(
                "Insecure Protocol",
                url,
                "Website is using HTTP instead of HTTPS. Sensitive information may be transmitted in clear text.",
                "High"
            )
            return
            
        # More checks could be added here if thorough scanning is enabled
        if self.options['thorough'] and url.startswith('https://'):
            try:
                response = requests.get(url, headers=self.headers, timeout=5)
                if 'Strict-Transport-Security' not in response.headers:
                    self.result_update.emit(
                        "Missing HSTS",
                        url,
                        "HTTPS is used but HSTS header is missing. This may allow SSL stripping attacks.",
                        "Medium"
                    )
            except Exception:
                pass
    
    def scan(self, url):
        """Scan a URL for basic web vulnerabilities"""
        try:
            # Reset stop event
            self._stop_event.clear()
            
            # Ensure URL starts with http/https
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            # Initial progress
            self.progress_update.emit(10)
            
            # Check SSL/TLS
            self._check_ssl_tls(url)
            if self._stop_event.is_set():
                return
                
            # Get the initial page
            response = requests.get(url, headers=self.headers, timeout=10)
            content = response.text
            headers = response.headers
            
            # Update progress
            self.progress_update.emit(30)
            
            # Define checks based on options
            checks = []
            if self.options['check_xss']:
                checks.append((self._check_xss, [url, content]))
            if self.options['check_sqli']:
                checks.append((self._check_sqli, [url]))
            if self.options['check_headers']:
                checks.append((self._check_insecure_headers, [url, headers]))
            if self.options['check_info']:
                checks.append((self._check_information_disclosure, [url, content, headers]))
            
            # Check for vulnerabilities
            total_checks = len(checks)
            progress_per_check = 60 / max(total_checks, 1)  # Remaining 60% distributed among checks
            
            for i, (check_func, args) in enumerate(checks):
                if self._stop_event.is_set():
                    break
                
                check_func(*args)
                
                # Update progress
                progress = 30 + int((i + 1) * progress_per_check)
                self.progress_update.emit(progress)
            
            # Thorough scanning - if enabled, check additional pages
            if self.options['thorough'] and not self._stop_event.is_set():
                # Find links to crawl
                link_pattern = r'href=["\']((?:/|https?://)[^"\']+)["\']'
                links = re.findall(link_pattern, content, re.IGNORECASE)
                
                # Only check up to 3 additional internal pages for performance
                internal_links = [link for link in links if not link.startswith(('http', 'https')) or url in link][:3]
                
                for i, link in enumerate(internal_links):
                    if self._stop_event.is_set():
                        break
                        
                    # Create absolute URL if needed
                    if not link.startswith(('http', 'https')):
                        link = urljoin(url, link)
                    
                    try:
                        response = requests.get(link, headers=self.headers, timeout=5)
                        sub_content = response.text
                        sub_headers = response.headers
                        
                        # Run all checks on this page
                        for check_func, _ in checks:
                            if check_func == self._check_xss:
                                check_func(link, sub_content)
                            elif check_func == self._check_sqli:
                                check_func(link)
                            elif check_func == self._check_insecure_headers:
                                check_func(link, sub_headers)
                            elif check_func == self._check_information_disclosure:
                                check_func(link, sub_content, sub_headers)
                    except Exception:
                        pass
                    
                    # Update progress
                    progress = 90 + int((i + 1) * 10 / len(internal_links))
                    self.progress_update.emit(progress)
            
            if not self._stop_event.is_set():
                self.progress_update.emit(100)
                self.scan_completed.emit()
        
        except Exception as e:
            self.scan_error.emit(str(e))
    
    def stop_scan(self):
        """Stop the vulnerability scan"""
        self._stop_event.set()
